//
//  main.swift
//  LeetCode-Solutions
//
//  Created by Vishal Patel on 7/28/17.
//  Copyright Â© 2017 Vishal Patel. All rights reserved.
//

import Foundation

var a = [1,2,3]
permute(&a)

//var a:[Int] = [0,2,9,8,2,4,]
//mergeSort(a: &a, p: 0, q: a.count)

//var words:[String] = ["oath","eat"]
//let trie = Trie(words: words)
//var grid:[[Character]] = [["o","a","a","n"],
//                          ["o","t","a","e"],
//                          ["o","h","a","n"],
//                          ["o","a","a","n"]]
//
//findWords(grid: &grid, words: words)

//var a = [2,5,8,4,6,9,3,10,7];
//quickSort(a: &a, p: 0, q: a.count-1)
//print("final")

/*
let a = maximumSubarray([-2, -3, 4, -1, -2, 1, 5, -3])
print(a)
*/


//let k = getSum(3,2)
//print(k)


/*
var a = [9,9,9]
let k = plusOne(a)
print(k)
*/

/*
var a = [1,0,2,3,4,0,5]
moveZerosOptimized(&a)
print(a)
*/

/*
let a1 = ListNode(1)
let b1 = ListNode(3)
let c1 = ListNode(5)

a1.next = b1
b1.next = c1

let a2 = ListNode(2)
let b2 = ListNode(4)
let c2 = ListNode(6)

a2.next = b2
b2.next = c2

var l = mergeTwoListsIterative(a1, a2)
while ( l != nil) {
    print(l?.val ?? "")
    l = l?.next
}
*/


//let n = ClimbStairs.numOfWays(n: 1)
//print(n)

//let tree = buildTree()
//let maxd = TreeSolutions.maximumDepth(tree)
//let k = TreeSolutions.diameter(tree)
//print(k)
/*

let stringManip_1 = StringManipulations.shiftString(k: 5, s: "HackerEarth")
print(stringManip_1)

let subsetSumResult = SubsetSum.subsetSum(input: [2,3,5,6], total: 8)

let rabinKarp = RabinKarpSearch()
let rabinKarpResult = rabinKarp.patternExist("abcdefghi","ghi")

let a = hammingDistance(1, 4)
print(a)

let b = hammingWeight(4)
print(b)

var m:[[Int]] = [[1,2,3],[4,5,6],[7,8,9]]
rotate(&m)

let aa = ListNode(1)
let bb = ListNode(2)
let cc = ListNode(3)
let dd = ListNode(4)
aa.next = bb
bb.next = cc
cc.next = dd
let ee = reverseList(aa)

*/
